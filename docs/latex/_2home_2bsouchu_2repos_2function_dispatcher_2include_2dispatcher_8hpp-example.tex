\hypertarget{_2home_2bsouchu_2repos_2function_dispatcher_2include_2dispatcher_8hpp-example}{}\doxysection{/home/bsouchu/repos/function\+\_\+dispatcher/include/dispatcher.\+hpp}
Call a function by its signature with the provided arguments.\+This function invokes the callable previously attached to the specified function signature with the given arguments. The arguments must match the types defined in the function signature. This function is blocking


\begin{DoxyTemplParams}{Template Parameters}
{\em Func\+Signature} & The function signature to call. \\
\hline
{\em Args} & The types of the arguments to pass to the callable. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em args} & The arguments to pass to the callable. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The return value of the callable.
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em No\+Handler$<$\+Func\+Signature$>$} & If no callable is attached to the function signature.\\
\hline
\end{DoxyExceptions}
struct Addition \{ using args\+\_\+t = std\+::tuple$<$int, int$>$; using return\+\_\+t = int; \};

dispatcher\+::attach$<$\+Addition$>$(\mbox{[}\mbox{]}(int a, int b) \{ return a + b; \}); int result = dispatcher\+::call$<$\+Addition$>$(3, 5); // result will be 8


\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#pragma once}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Copyright 2025 Volvo Car Corporation}}
\DoxyCodeLine{\textcolor{comment}{// Licensed under the Apache License, Version 2.0 (the "{}License"{});}}
\DoxyCodeLine{\textcolor{comment}{// you may not use this file except in compliance with the License.}}
\DoxyCodeLine{\textcolor{comment}{// You may obtain a copy of the License at}}
\DoxyCodeLine{\textcolor{comment}{//}}
\DoxyCodeLine{\textcolor{comment}{//     http://www.apache.org/licenses/LICENSE-\/2.0}}
\DoxyCodeLine{\textcolor{comment}{//}}
\DoxyCodeLine{\textcolor{comment}{// Unless required by applicable law or agreed to in writing, software}}
\DoxyCodeLine{\textcolor{comment}{// distributed under the License is distributed on an "{}AS IS"{} BASIS,}}
\DoxyCodeLine{\textcolor{comment}{// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.}}
\DoxyCodeLine{\textcolor{comment}{// See the License for the specific language governing permissions and}}
\DoxyCodeLine{\textcolor{comment}{// limitations under the License.}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <boost/asio.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <boost/date\_time/posix\_time/posix\_time.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <boost/fiber/all.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <boost/optional.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <boost/signals2.hpp>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <functional>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <queue>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <thread>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <tuple>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <utility>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{namespace }dispatcher \{}
\DoxyCodeLine{\textcolor{keyword}{namespace }internal \{}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} ReturnType, \textcolor{keyword}{typename} Tuple>}
\DoxyCodeLine{\textcolor{keyword}{struct }FunctionFromTuple;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} ReturnType, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{\textcolor{keyword}{struct }FunctionFromTuple<ReturnType, std::tuple<Args...>> \{}
\DoxyCodeLine{    \textcolor{keyword}{using} type = std::function<ReturnType(Args...)>;}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} ReturnType, \textcolor{keyword}{typename} Tuple>}
\DoxyCodeLine{\textcolor{keyword}{struct }ReturnTypeFromCallable;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} Callable, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{\textcolor{keyword}{struct }ReturnTypeFromCallable<Callable, std::tuple<Args...>> \{}
\DoxyCodeLine{    \textcolor{keyword}{using} type = \textcolor{keyword}{typename} std::result\_of<Callable(Args...)>::type;}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} Tuple>}
\DoxyCodeLine{\textcolor{keyword}{struct }SignalFromTuple;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{\textcolor{keyword}{struct }SignalFromTuple<std::tuple<Args...>> \{}
\DoxyCodeLine{    \textcolor{keyword}{using} type = boost::signals2::signal<void(Args...)>;}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename}...>}
\DoxyCodeLine{\textcolor{keyword}{using} void\_t = void;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} FuncSignature, \textcolor{keyword}{typename} = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{\textcolor{keyword}{struct }has\_return\_t : std::false\_type \{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} FuncSignature>}
\DoxyCodeLine{\textcolor{keyword}{struct }has\_return\_t<FuncSignature, void\_t<typename FuncSignature::return\_t>> : std::true\_type \{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} FuncSignature, \textcolor{keywordtype}{bool} HasReturnT>}
\DoxyCodeLine{\textcolor{keyword}{struct }return\_t\_or\_default \{}
\DoxyCodeLine{    \textcolor{keyword}{using} type = void;}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} FuncSignature>}
\DoxyCodeLine{\textcolor{keyword}{struct }return\_t\_or\_default<FuncSignature, true> \{}
\DoxyCodeLine{    \textcolor{keyword}{using} type = \textcolor{keyword}{typename} FuncSignature::return\_t;}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} FuncSignature, \textcolor{keyword}{typename} = \textcolor{keywordtype}{void}>}
\DoxyCodeLine{\textcolor{keyword}{struct }has\_args\_t : std::false\_type \{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} FuncSignature>}
\DoxyCodeLine{\textcolor{keyword}{struct }has\_args\_t<FuncSignature, void\_t<typename FuncSignature::args\_t>> : std::true\_type \{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} FuncSignature, \textcolor{keywordtype}{bool} HasReturnT>}
\DoxyCodeLine{\textcolor{keyword}{struct }args\_t\_or\_default \{}
\DoxyCodeLine{    \textcolor{keyword}{using} type = std::tuple<>;}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} FuncSignature>}
\DoxyCodeLine{\textcolor{keyword}{struct }args\_t\_or\_default<FuncSignature, true> \{}
\DoxyCodeLine{    \textcolor{keyword}{using} type = \textcolor{keyword}{typename} FuncSignature::args\_t;}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Default network}}
\DoxyCodeLine{\textcolor{keyword}{struct }Default \{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\}  \textcolor{comment}{// namespace internal}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} FuncSignature>}
\DoxyCodeLine{\textcolor{keyword}{class }NoHandler : \textcolor{keyword}{public} std::exception \{}
\DoxyCodeLine{  \textcolor{keyword}{public}:}
\DoxyCodeLine{    \textcolor{keyword}{const} \textcolor{keywordtype}{char} *what() \textcolor{keyword}{const} noexcept \textcolor{keyword}{override}}
\DoxyCodeLine{    \{}
\DoxyCodeLine{        \textcolor{keywordflow}{return} \textcolor{stringliteral}{"{}Function was called but no handler was attached"{}};}
\DoxyCodeLine{    \}}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{namespace }internal \{}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} FuncSignature, \textcolor{keyword}{typename} func\_type>}
\DoxyCodeLine{func\_type \&GetFunction()}
\DoxyCodeLine{\{}
\DoxyCodeLine{    \textcolor{keyword}{static} func\_type \textcolor{keyword}{function};}
\DoxyCodeLine{    \textcolor{keywordflow}{return} \textcolor{keyword}{function};}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} FuncSignature>}
\DoxyCodeLine{\textcolor{keyword}{struct }FunctionDispatcher \{}
\DoxyCodeLine{    \textcolor{keyword}{template} <\textcolor{keyword}{typename} Callable>}
\DoxyCodeLine{    \textcolor{keyword}{static} \textcolor{keywordtype}{void} attach(Callable \&\&callable)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{        GetFunction<FuncSignature, func\_type>() = std::forward<Callable>(callable);}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keyword}{static} \textcolor{keywordtype}{void} detach()}
\DoxyCodeLine{    \{}
\DoxyCodeLine{        GetFunction<FuncSignature, func\_type>() = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{    \textcolor{keyword}{static} \textcolor{keyword}{auto} call(Args \&\&...args)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{        \textcolor{keywordflow}{if} (GetFunction<FuncSignature, func\_type>() == \textcolor{keyword}{nullptr}) \{}
\DoxyCodeLine{            \textcolor{keywordflow}{throw} NoHandler<FuncSignature>\{\};}
\DoxyCodeLine{        \}}
\DoxyCodeLine{        \textcolor{keywordflow}{return} GetFunction<FuncSignature, func\_type>()(std::forward<Args>(args)...);}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keyword}{using} return\_t = \textcolor{keyword}{typename} return\_t\_or\_default<FuncSignature, has\_return\_t<FuncSignature>::value>::type;}
\DoxyCodeLine{    \textcolor{keyword}{using} args\_t = \textcolor{keyword}{typename} args\_t\_or\_default<FuncSignature, has\_args\_t<FuncSignature>::value>::type;}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keyword}{using} func\_type = \textcolor{keyword}{typename} FunctionFromTuple<return\_t, args\_t>::type;}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{class }MemoryPool \{}
\DoxyCodeLine{  \textcolor{keyword}{public}:}
\DoxyCodeLine{    MemoryPool(std::size\_t size) : size\_(size)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{    \}}
\DoxyCodeLine{    \string~MemoryPool()}
\DoxyCodeLine{    \{}
\DoxyCodeLine{        \textcolor{keywordflow}{while} (!allocated\_blocks\_.empty()) \{}
\DoxyCodeLine{            \textcolor{keyword}{auto} memory\_block = allocated\_blocks\_.front();}
\DoxyCodeLine{            allocated\_blocks\_.pop();}
\DoxyCodeLine{            std::free(memory\_block);}
\DoxyCodeLine{        \}}
\DoxyCodeLine{    \}}
\DoxyCodeLine{    MemoryPool(\textcolor{keyword}{const} MemoryPool \&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{    MemoryPool(MemoryPool \&\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{    MemoryPool \&operator=(\textcolor{keyword}{const} MemoryPool \&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{    MemoryPool \&operator=(MemoryPool \&\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordtype}{void} *allocate()}
\DoxyCodeLine{    \{}
\DoxyCodeLine{        std::unique\_lock<std::mutex> ul\{m\_\};}
\DoxyCodeLine{        \textcolor{keywordflow}{if} (allocated\_blocks\_.empty()) \{}
\DoxyCodeLine{            \textcolor{keywordtype}{void} *memory = std::malloc(size\_);}
\DoxyCodeLine{            \textcolor{keywordflow}{if} (!memory) \{}
\DoxyCodeLine{                \textcolor{keywordflow}{throw} std::bad\_alloc();}
\DoxyCodeLine{            \}}
\DoxyCodeLine{            \textcolor{keywordflow}{return} memory;}
\DoxyCodeLine{        \}}
\DoxyCodeLine{        \textcolor{keyword}{auto} memory = allocated\_blocks\_.front();}
\DoxyCodeLine{        allocated\_blocks\_.pop();}
\DoxyCodeLine{        \textcolor{keywordflow}{return} memory;}
\DoxyCodeLine{    \}}
\DoxyCodeLine{    \textcolor{keywordtype}{void} free(\textcolor{keywordtype}{void} *memory\_block)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{        std::unique\_lock<std::mutex> ul\{m\_\};}
\DoxyCodeLine{        allocated\_blocks\_.push(memory\_block);}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    std::size\_t get\_size()}
\DoxyCodeLine{    \{}
\DoxyCodeLine{        \textcolor{keywordflow}{return} size\_;}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keyword}{private}:}
\DoxyCodeLine{    std::size\_t size\_;}
\DoxyCodeLine{    std::queue<void *> allocated\_blocks\_;}
\DoxyCodeLine{    std::mutex m\_;}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{class }CustomStackAllocator \{}
\DoxyCodeLine{  \textcolor{keyword}{public}:}
\DoxyCodeLine{    CustomStackAllocator(MemoryPool *memory\_pool) : memory\_pool\_(memory\_pool)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    boost::context::stack\_context allocate()}
\DoxyCodeLine{    \{}
\DoxyCodeLine{        boost::context::stack\_context sctx;}
\DoxyCodeLine{        sctx.size = memory\_pool\_-\/>get\_size();}
\DoxyCodeLine{        sctx.sp = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char} *\textcolor{keyword}{>}(memory\_pool\_-\/>allocate()) + sctx.size;}
\DoxyCodeLine{        \textcolor{keywordflow}{return} sctx;}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordtype}{void} deallocate(boost::context::stack\_context \&sctx) BOOST\_NOEXCEPT\_OR\_NOTHROW}
\DoxyCodeLine{    \{}
\DoxyCodeLine{        BOOST\_ASSERT(sctx.sp);}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{keywordtype}{void} *vp = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char} *\textcolor{keyword}{>}(sctx.sp) -\/ sctx.size;}
\DoxyCodeLine{        memory\_pool\_-\/>free(vp);}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keyword}{private}:}
\DoxyCodeLine{    MemoryPool *memory\_pool\_;}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} Network>}
\DoxyCodeLine{\textcolor{keyword}{class }EventLoop \{}
\DoxyCodeLine{  \textcolor{keyword}{public}:}
\DoxyCodeLine{    EventLoop()}
\DoxyCodeLine{        : work\_guard\_\{boost::asio::make\_work\_guard(io\_context\_)\}, work\_thread\_\{[\textcolor{keyword}{this}] \{}
\DoxyCodeLine{              \textcolor{keywordflow}{while} (!stopped\_) \{}
\DoxyCodeLine{                  io\_context\_.poll\_one();}
\DoxyCodeLine{                  boost::this\_fiber::yield();}
\DoxyCodeLine{              \}}
\DoxyCodeLine{          \}\}}
\DoxyCodeLine{    \{}
\DoxyCodeLine{    \}}
\DoxyCodeLine{    \string~EventLoop()}
\DoxyCodeLine{    \{}
\DoxyCodeLine{        Stop();}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    EventLoop(\textcolor{keyword}{const} EventLoop \&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{    EventLoop(EventLoop \&\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{    EventLoop \&operator=(\textcolor{keyword}{const} EventLoop \&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{    EventLoop \&operator=(EventLoop \&\&) = \textcolor{keyword}{delete};}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordtype}{void} SetWorkerThreadsAmount(\textcolor{keywordtype}{int} threads)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{        \textcolor{keywordflow}{while} (additional\_work\_threads\_.size() < threads -\/ 1) \{}
\DoxyCodeLine{            additional\_work\_threads\_.emplace\_back([\textcolor{keyword}{this}] \{}
\DoxyCodeLine{                \textcolor{keywordflow}{while} (!stopped\_) \{}
\DoxyCodeLine{                    io\_context\_.poll\_one();}
\DoxyCodeLine{                    boost::this\_fiber::yield();}
\DoxyCodeLine{                \}}
\DoxyCodeLine{            \});}
\DoxyCodeLine{        \}}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{    \textcolor{keywordtype}{void} Post(T \&\&task)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{        boost::asio::post(io\_context\_, [\textcolor{keyword}{this}, task = std::forward<T>(task)]() \textcolor{keyword}{mutable} \{}
\DoxyCodeLine{            boost::fibers::fiber(}
\DoxyCodeLine{                boost::fibers::launch::dispatch, std::allocator\_arg,}
\DoxyCodeLine{                CustomStackAllocator\{\&memory\_pool\_\}, std::forward<T>(task))}
\DoxyCodeLine{                .detach();}
\DoxyCodeLine{        \});}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordtype}{void} Stop()}
\DoxyCodeLine{    \{}
\DoxyCodeLine{        work\_guard\_.reset();}
\DoxyCodeLine{        io\_context\_.stop();}
\DoxyCodeLine{        stopped\_ = \textcolor{keyword}{true};}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{keywordflow}{if} (work\_thread\_.joinable()) \{}
\DoxyCodeLine{            work\_thread\_.join();}
\DoxyCodeLine{        \}}
\DoxyCodeLine{        \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \&thread : additional\_work\_threads\_) \{}
\DoxyCodeLine{            \textcolor{keywordflow}{if} (thread.joinable()) \{}
\DoxyCodeLine{                thread.join();}
\DoxyCodeLine{            \}}
\DoxyCodeLine{        \}}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    boost::asio::io\_context \&GetIOContext()}
\DoxyCodeLine{    \{}
\DoxyCodeLine{        \textcolor{keywordflow}{return} io\_context\_;}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keyword}{private}:}
\DoxyCodeLine{    boost::asio::io\_context io\_context\_;}
\DoxyCodeLine{    boost::asio::executor\_work\_guard<decltype(io\_context\_.get\_executor())> work\_guard\_;}
\DoxyCodeLine{    std::thread work\_thread\_;}
\DoxyCodeLine{    std::vector<std::thread> additional\_work\_threads\_;}
\DoxyCodeLine{    std::atomic<bool> stopped\_\{\textcolor{keyword}{false}\};}
\DoxyCodeLine{    MemoryPool memory\_pool\_\{30000\};}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} Network = Default>}
\DoxyCodeLine{EventLoop<Network> \&getEventLoop()}
\DoxyCodeLine{\{}
\DoxyCodeLine{    \textcolor{keyword}{static} EventLoop<Network> event\_loop;}
\DoxyCodeLine{    \textcolor{keywordflow}{return} event\_loop;}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} F, \textcolor{keyword}{typename} Tuple, std::size\_t... Is>}
\DoxyCodeLine{\textcolor{keyword}{auto} call\_with\_tuple(F \&\&f, Tuple \&\&t, std::index\_sequence<Is...>)}
\DoxyCodeLine{\{}
\DoxyCodeLine{    \textcolor{keywordflow}{return} f(std::get<Is>(std::forward<Tuple>(t))...);}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} F, \textcolor{keyword}{typename} Tuple>}
\DoxyCodeLine{\textcolor{keyword}{auto} call\_with\_tuple(F \&\&f, Tuple \&\&t)}
\DoxyCodeLine{\{}
\DoxyCodeLine{    constexpr \textcolor{keyword}{auto} size = std::tuple\_size<std::decay\_t<Tuple>>::value;}
\DoxyCodeLine{    \textcolor{keywordflow}{return} call\_with\_tuple(std::forward<F>(f), std::forward<Tuple>(t), std::make\_index\_sequence<size>\{\});}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} FuncSignature, \textcolor{keyword}{typename} Network, \textcolor{keyword}{typename} signal\_type>}
\DoxyCodeLine{signal\_type \&GetSignal()}
\DoxyCodeLine{\{}
\DoxyCodeLine{    \textcolor{keyword}{static} signal\_type signal;}
\DoxyCodeLine{    \textcolor{keywordflow}{return} signal;}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} FuncSignature, \textcolor{keyword}{typename} Network = \textcolor{keywordtype}{int}ernal::Default>}
\DoxyCodeLine{\textcolor{keyword}{struct }EventDispatcher \{}
\DoxyCodeLine{    \textcolor{keyword}{template} <\textcolor{keyword}{typename} Callable>}
\DoxyCodeLine{    \textcolor{keyword}{static} boost::signals2::connection subscribe(Callable \&\&callable)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{        \textcolor{keywordflow}{return} GetSignal<FuncSignature, Network, signal\_type>().connect(std::forward<Callable>(callable));}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keyword}{template} <\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{    \textcolor{keyword}{static} \textcolor{keywordtype}{void} publish(Args \&\&...args)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{        \textcolor{keyword}{auto} argsTuple = std::make\_tuple(std::forward<Args>(args)...);}
\DoxyCodeLine{        getEventLoop<Network>().Post([argsTuple = std::move(argsTuple)]() \textcolor{keyword}{mutable} \{}
\DoxyCodeLine{            call\_with\_tuple(GetSignal<FuncSignature, Network, signal\_type>(), std::move(argsTuple));}
\DoxyCodeLine{        \});}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keyword}{using} args\_t = \textcolor{keyword}{typename} args\_t\_or\_default<FuncSignature, has\_args\_t<FuncSignature>::value>::type;}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keyword}{using} signal\_type = \textcolor{keyword}{typename} SignalFromTuple<args\_t>::type;}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{inline} boost::optional<boost::asio::deadline\_timer::traits\_type::time\_type> \&Now()}
\DoxyCodeLine{\{}
\DoxyCodeLine{    \textcolor{keyword}{static} boost::optional<boost::asio::deadline\_timer::traits\_type::time\_type> now;}
\DoxyCodeLine{    \textcolor{keywordflow}{return} now;}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// This clock can be settable in unit test}}
\DoxyCodeLine{\textcolor{keyword}{struct }MockableClock \{}
\DoxyCodeLine{    \textcolor{keyword}{typedef} boost::asio::deadline\_timer::traits\_type source\_traits;}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keyword}{public}:}
\DoxyCodeLine{    \textcolor{keyword}{typedef} source\_traits::time\_type time\_type;}
\DoxyCodeLine{    \textcolor{keyword}{typedef} source\_traits::duration\_type duration\_type;}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keyword}{static} time\_type now()}
\DoxyCodeLine{    \{}
\DoxyCodeLine{        \textcolor{keywordflow}{if} (Now()) \{}
\DoxyCodeLine{            \textcolor{keywordflow}{return} *Now();}
\DoxyCodeLine{        \}}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{keywordflow}{return} chrono\_to\_ptime(std::chrono::system\_clock::now());}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// To be used in testing only}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keyword}{static} \textcolor{keywordtype}{void} set\_now(time\_type t = chrono\_to\_ptime(std::chrono::system\_clock::now()))}
\DoxyCodeLine{    \{}
\DoxyCodeLine{        Now() = t;}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keyword}{template} <\textcolor{keyword}{typename} Duration>}
\DoxyCodeLine{    \textcolor{keyword}{static} \textcolor{keywordtype}{void} advance\_time(Duration \&\&d)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{        \textcolor{keywordflow}{if} (!Now()) \{}
\DoxyCodeLine{            \textcolor{keywordflow}{return};}
\DoxyCodeLine{        \}}
\DoxyCodeLine{        *Now() = add(*Now(),}
\DoxyCodeLine{                     boost::posix\_time::milliseconds(std::chrono::duration\_cast<std::chrono::milliseconds>(d).count()));}
\DoxyCodeLine{        std::this\_thread::sleep\_for(std::chrono::microseconds(1100));}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keyword}{static} time\_type add(time\_type t, duration\_type d)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{        \textcolor{keywordflow}{return} source\_traits::add(t, d);}
\DoxyCodeLine{    \}}
\DoxyCodeLine{    \textcolor{keyword}{static} duration\_type subtract(time\_type t1, time\_type t2)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{        \textcolor{keywordflow}{return} source\_traits::subtract(t1, t2);}
\DoxyCodeLine{    \}}
\DoxyCodeLine{    \textcolor{keyword}{static} \textcolor{keywordtype}{bool} less\_than(time\_type t1, time\_type t2)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{        \textcolor{keywordflow}{return} source\_traits::less\_than(t1, t2);}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keyword}{static} boost::posix\_time::time\_duration to\_posix\_duration(duration\_type d)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{        \textcolor{keywordflow}{if} (!Now()) \{}
\DoxyCodeLine{            \textcolor{keywordflow}{return} d;}
\DoxyCodeLine{        \}}
\DoxyCodeLine{        \textcolor{keywordflow}{return} d < boost::posix\_time::milliseconds(1) ? d : boost::posix\_time::milliseconds(1);}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keyword}{static} boost::posix\_time::ptime chrono\_to\_ptime(\textcolor{keyword}{const} std::chrono::system\_clock::time\_point \&tp)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{        \textcolor{keyword}{auto} duration = tp.time\_since\_epoch();}
\DoxyCodeLine{        \textcolor{keyword}{auto} seconds = std::chrono::duration\_cast<std::chrono::seconds>(duration);}
\DoxyCodeLine{        \textcolor{keyword}{auto} microseconds = std::chrono::duration\_cast<std::chrono::microseconds>(duration -\/ seconds);}
\DoxyCodeLine{        \textcolor{keywordflow}{return} boost::posix\_time::from\_time\_t(seconds.count()) + boost::posix\_time::microseconds(microseconds.count());}
\DoxyCodeLine{    \}}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\}  \textcolor{comment}{// namespace internal}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// ========================================= API ========================================= //}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} FuncSignature, \textcolor{keyword}{typename} Callable>}
\DoxyCodeLine{\textcolor{keywordtype}{void} attach(Callable \&\&callable)}
\DoxyCodeLine{\{}
\DoxyCodeLine{    static\_assert(}
\DoxyCodeLine{        std::is\_same<\textcolor{keyword}{typename} internal::FunctionDispatcher<FuncSignature>::return\_t,}
\DoxyCodeLine{                     \textcolor{keyword}{typename} internal::ReturnTypeFromCallable<}
\DoxyCodeLine{                         Callable, \textcolor{keyword}{typename} internal::FunctionDispatcher<FuncSignature>::args\_t>::type>::value,}
\DoxyCodeLine{        \textcolor{stringliteral}{"{}The return values of the callable is not matching the function signature"{}});}
\DoxyCodeLine{    internal::FunctionDispatcher<FuncSignature>::template attach<Callable>(std::forward<Callable>(callable));}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} FuncSignature>}
\DoxyCodeLine{\textcolor{keywordtype}{void} detach()}
\DoxyCodeLine{\{}
\DoxyCodeLine{    internal::FunctionDispatcher<FuncSignature>::detach();}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} FuncSignature, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{\textcolor{keyword}{auto} call(Args \&\&...args)}
\DoxyCodeLine{\{}
\DoxyCodeLine{    \textcolor{keywordflow}{return} internal::FunctionDispatcher<FuncSignature>::call(std::forward<Args>(args)...);}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} FuncSignature, \textcolor{keyword}{typename} Network = internal::Default, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{\textcolor{keyword}{auto} async\_call(Args \&\&...args)}
\DoxyCodeLine{\{}
\DoxyCodeLine{    boost::fibers::promise<typename internal::FunctionDispatcher<FuncSignature>::return\_t> promise;}
\DoxyCodeLine{    \textcolor{keyword}{auto} future = promise.get\_future();}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keyword}{using} func\_type = \textcolor{keyword}{typename} internal::FunctionDispatcher<FuncSignature>::func\_type;}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keyword}{auto} argsTuple = std::make\_tuple(std::forward<Args>(args)...);}
\DoxyCodeLine{    internal::getEventLoop<Network>().Post([promise = std::move(promise), argsTuple = std::move(argsTuple)]() \textcolor{keyword}{mutable} \{}
\DoxyCodeLine{        promise.set\_value(}
\DoxyCodeLine{            internal::call\_with\_tuple(internal::GetFunction<FuncSignature, func\_type>(), std::move(argsTuple)));}
\DoxyCodeLine{    \});}
\DoxyCodeLine{    \textcolor{keywordflow}{return} future;}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} FuncSignature, \textcolor{keyword}{typename} Network = \textcolor{keywordtype}{int}ernal::Default, \textcolor{keyword}{typename} Callable>}
\DoxyCodeLine{boost::signals2::connection subscribe(Callable \&\&callable)}
\DoxyCodeLine{\{}
\DoxyCodeLine{    \textcolor{keywordflow}{return} internal::EventDispatcher<FuncSignature, Network>::template subscribe(std::forward<Callable>(callable));}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} FuncSignature, \textcolor{keyword}{typename} Network = \textcolor{keywordtype}{int}ernal::Default>}
\DoxyCodeLine{boost::fibers::future<std::nullptr\_t> expect()}
\DoxyCodeLine{\{}
\DoxyCodeLine{    \textcolor{keyword}{auto} promise = std::make\_shared<boost::fibers::promise<std::nullptr\_t>>();}
\DoxyCodeLine{    \textcolor{keyword}{auto} future = promise-\/>get\_future();}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keyword}{auto} connection = std::make\_shared<boost::signals2::connection>();}
\DoxyCodeLine{    *connection = internal::EventDispatcher<FuncSignature, Network>::template subscribe(}
\DoxyCodeLine{        [promise, connection](\textcolor{keyword}{auto} \&\&...args) \textcolor{keyword}{mutable} \{}
\DoxyCodeLine{            connection-\/>disconnect();}
\DoxyCodeLine{            promise-\/>set\_value(\{\});}
\DoxyCodeLine{        \});}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordflow}{return} future;}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} FuncSignature, \textcolor{keyword}{typename} Network = \textcolor{keywordtype}{int}ernal::Default, \textcolor{keyword}{typename} Callable>}
\DoxyCodeLine{boost::fibers::future<std::nullptr\_t> expect(Callable \&\&callable)}
\DoxyCodeLine{\{}
\DoxyCodeLine{    \textcolor{keyword}{auto} promise = std::make\_shared<boost::fibers::promise<std::nullptr\_t>>();}
\DoxyCodeLine{    \textcolor{keyword}{auto} future = promise-\/>get\_future();}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keyword}{auto} connection = std::make\_shared<boost::signals2::connection>();}
\DoxyCodeLine{    *connection = internal::EventDispatcher<FuncSignature, Network>::template subscribe(}
\DoxyCodeLine{        [promise, callable = std::forward<Callable>(callable), connection](\textcolor{keyword}{auto} \&\&...args) \textcolor{keyword}{mutable} \{}
\DoxyCodeLine{            connection-\/>disconnect();}
\DoxyCodeLine{            callable(std::forward<decltype(args)>(args)...);}
\DoxyCodeLine{            promise-\/>set\_value(\{\});}
\DoxyCodeLine{        \});}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordflow}{return} future;}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} FuncSignature, \textcolor{keyword}{typename} Network = internal::Default, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{\textcolor{keywordtype}{void} publish(Args \&\&...args)}
\DoxyCodeLine{\{}
\DoxyCodeLine{    internal::EventDispatcher<FuncSignature, Network>::publish(std::forward<Args>(args)...);}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} Network = \textcolor{keywordtype}{int}ernal::Default, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{\textcolor{keywordtype}{void} post(T \&\&task)}
\DoxyCodeLine{\{}
\DoxyCodeLine{    internal::getEventLoop<Network>().Post(std::forward<T>(task));}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} Network = \textcolor{keywordtype}{int}ernal::Default>}
\DoxyCodeLine{\textcolor{keywordtype}{void} set\_worker\_threads(\textcolor{keywordtype}{int} thread\_count)}
\DoxyCodeLine{\{}
\DoxyCodeLine{    internal::getEventLoop<Network>().SetWorkerThreadsAmount(thread\_count);}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} Network>}
\DoxyCodeLine{\textcolor{keyword}{class }Timer \{}
\DoxyCodeLine{  \textcolor{keyword}{public}:}
\DoxyCodeLine{    \mbox{\hyperlink{classdispatcher_1_1Timer_a191563b89b2b5555ab9fc5c0bc6004b1}{Timer}}() : timer\_(internal::getEventLoop<Network>().GetIOContext())}
\DoxyCodeLine{    \{}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordtype}{void} \mbox{\hyperlink{classdispatcher_1_1Timer_ace1836a5bfe91825fd55486189e33d63}{Cancel}}()}
\DoxyCodeLine{    \{}
\DoxyCodeLine{        timer\_.cancel();}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keyword}{template} <\textcolor{keyword}{typename} Duration, \textcolor{keyword}{typename} Callback>}
\DoxyCodeLine{    \textcolor{keywordtype}{void} DoIn(Duration duration, Callback \&\&callback)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{        timer\_.expires\_from\_now(}
\DoxyCodeLine{            boost::posix\_time::milliseconds(std::chrono::duration\_cast<std::chrono::milliseconds>(duration).count()));}
\DoxyCodeLine{        timer\_.async\_wait([callback = std::forward<Callback>(callback)](\textcolor{keyword}{const} boost::system::error\_code \&ec) \textcolor{keyword}{mutable} \{}
\DoxyCodeLine{            \textcolor{keywordflow}{if} (ec != boost::asio::error::operation\_aborted) \{}
\DoxyCodeLine{                internal::getEventLoop<Network>().Post(std::forward<Callback>(callback));}
\DoxyCodeLine{            \}}
\DoxyCodeLine{        \});}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keyword}{template} <\textcolor{keyword}{typename} Duration, \textcolor{keyword}{typename} Callback>}
\DoxyCodeLine{    \textcolor{keywordtype}{void} DoEvery(Duration duration, Callback \&\&callback)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{        timer\_.expires\_from\_now(}
\DoxyCodeLine{            boost::posix\_time::milliseconds(std::chrono::duration\_cast<std::chrono::milliseconds>(duration).count()));}
\DoxyCodeLine{        timer\_.async\_wait(}
\DoxyCodeLine{            [\textcolor{keyword}{this}, callback = std::forward<Callback>(callback), duration](\textcolor{keyword}{const} boost::system::error\_code \&ec) \textcolor{keyword}{mutable} \{}
\DoxyCodeLine{                \textcolor{keywordflow}{if} (ec != boost::asio::error::operation\_aborted) \{}
\DoxyCodeLine{                    internal::getEventLoop<Network>().Post(callback);}
\DoxyCodeLine{                    DoEvery(duration, std::forward<Callback>(callback));}
\DoxyCodeLine{                \}}
\DoxyCodeLine{            \});}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keyword}{private}:}
\DoxyCodeLine{    boost::asio::basic\_deadline\_timer<boost::posix\_time::ptime, internal::MockableClock> timer\_;}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{using} DefaultTimer = Timer<internal::Default>;}
\DoxyCodeLine{}
\DoxyCodeLine{\}  \textcolor{comment}{// namespace dispatcher}}

\end{DoxyCodeInclude}
 